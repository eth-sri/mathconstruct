from math_construct.problems.templates import TEMPLATES
PROBLEM_TEMPLATE = TEMPLATES["backups/problem_1990_3.py"]

import math
import random
from math_construct.problems.problem import Problem, ProblemConfig, Tag, CheckerTag
from math_construct.templates import get_list_template
from itertools import permutations


EXTRA_FORMATTING_INSTRUCTIONS = r"""Output your answer as a single list of integers, where the first 14 integers are for necklace $\, A \,$ and the last 19 integers are for necklace $\, B \,$."""

# Brute force solution generated by Claude
def is_relatively_prime(a, b):
    return math.gcd(a, b) == 1

def is_valid_necklace(nums):
    n = len(nums)
    for i in range(n):
        if not is_relatively_prime(nums[i], nums[(i + 1) % n]):
            return False
    return True

def brute_force(n: int, max_iter: int = 1000000):
    nums = list(range(n, n + 33))
    # Try different splits of the numbers into two lists
    for perm in permutations(nums, 14):  # Try combinations for first necklace
        max_iter -= 1
        if max_iter == 0:
            return None
        necklace_a = list(perm)
        if not is_valid_necklace(necklace_a):
            continue
        
        remaining = [x for x in nums if x not in necklace_a]
        if is_valid_necklace(remaining):
            return necklace_a + remaining
    return None

def get_solution(n: int) -> list[list[int]]:
    k = 0
    while math.gcd(n+k, n+k+15) != 1 or math.gcd(n+k+14, n+k+1) != 1:
        k += 1
    a = [n+k+i for i in range(1, 15)]
    b = [n+i for i in range(k+1)] + [n+k+15+i for i in range(19-(k+1))]
    return a + b

class Problem13(Problem):
    """1990 USAMO Problem 3"""
    config = ProblemConfig(
        name=Problem.get_name(__file__),
        statement=PROBLEM_TEMPLATE,
        formatting_instructions=get_list_template(extra_instructions=EXTRA_FORMATTING_INSTRUCTIONS),
        parameters=["n"],
        source="1990 USAMO Problem 3",
        original_parameters={"n": 233},
        original_solution=get_solution(233),
        problem_url="https://artofproblemsolving.com/wiki/index.php/1990_USAMO_Problems/Problem_3",
        solution_url="https://artofproblemsolving.com/wiki/index.php/1990_USAMO_Problems/Problem_3",
        tags=[Tag.COMBINATORICS, Tag.IS_GENERALIZED, Tag.IS_SIMPLIFIED, Tag.FIND_ANY]
    )
    n: int

    def __init__(self, n: int):
        self.n = n

    def get_problem(self):
        return PROBLEM_TEMPLATE.format(n=self.n)

    def check(self, x: list[int]) -> bool:
        if len(set(x)) != 33 or len(x) != 33:
            return False, f"List either has duplicate elements or is not of length 33", CheckerTag.INCORRECT_LENGTH
        if not all(isinstance(y, int) for y in x):
            return False, "All elements should be integers", CheckerTag.INCORRECT_FORMAT
        for i in range(33):
            if x[i] < self.n or x[i] > self.n + 32:
                return False, f"Element {x[i]} is not in the range [{self.n}, {self.n+32}]", CheckerTag.INCORRECT_FORMAT
        a, b = x[:14], x[14:]
        for i in range(14):
            if math.gcd(a[i], a[(i+1)%14]) != 1:
                return False, f"Elements {a[i]} and {a[(i+1)%14]} are not relatively prime", CheckerTag.INCORRECT_SOLUTION
        for i in range(19):
            if math.gcd(b[i], b[(i+1)%19]) != 1:
                return False, f"Elements {b[i]} and {b[(i+1)%19]} are not relatively prime", CheckerTag.INCORRECT_SOLUTION
        return True, "OK", CheckerTag.CORRECT

    @staticmethod
    def generate() -> "Problem13":
        nontrivial = [] 
        for i in range(50, 1001):
            n = 2 * i +  1 
            if math.gcd(n, n+13) == 1 and math.gcd(n+14, n+32) == 1:
                continue 
            nontrivial.append(n) 
        n = random.choice(nontrivial)
        return Problem13(n)

    def get_solution(self):
        return get_solution(self.n)
